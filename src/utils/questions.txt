- what is the FILE type and can I just use integers to represent and input/output stream?
- can unistd.h and fcntl.h be included or are the part of the standard library
- do error functions need to be implemented
- is naming scheme alright? (_functionName)
- should we be using register variables
- should we be using mem methods instead of str methods?
- are we allowed to include stdlib.h as long as we only use system call
  wrappers and builtin types? (yes)
- can we initialize arrays like char line[1024] (yes this is static allocation)
path 
jobs

parent receives signal from terminated child with sigchld to clear it
from the process table

Background processes:
- linked list of child processes (not a queue since child processes don't
  necessarily operate with first in first out logic) for background processes

- should the linked list only store background jobs or all jobs (an & command
  can result in zombie children)

- when a child is created with &, store it in linked list at tail. 
  when a child process terminates, traverse the list looking for its pid.
  or should we always be searching after every command. Do signals
  solve this problem (since the child directly notifies the parent)

- do we have to statically allocate the linked list?
- if the heap can be used to allocate many different types,
  what should it be an array of (i thought size_t); keep as char array, use casting to store other types


- does token need to be statically allocated (tokenize())? is token = input fine or should it be strcpy

-does a command structure need to be allocated followed by its fields, or just the fields
-if just the fields, how is the structure getting allocated

struct BlockInfo* allocatedBlocks[MAX_BLOCKS];

if (numAllocatedBlocks < MAX_BLOCKS) {
    struct BlockInfo* blockInfo = malloc(sizeof(struct BlockInfo));
    if (blockInfo == NULL) {
        printf("BLOCKINFO ALLOCATION FAILED\n");
        return NULL;
    }

    blockInfo->ptr = ptr;
    blockInfo->size = block_sz;
    allocatedBlocks[numAllocatedBlocks] = blockInfo;
    numAllocatedBlocks++;
} else {
    printf("MAX BLOCKS EXCEEDED\n");
}

  vs.

struct BlockInfo allocatedBlocks[MAX_BLOCKS];
if (numAllocatedBlocks < MAX_BLOCKS) {
    allocatedBlocks[numAllocatedBlocks].ptr = ptr;
    allocatedBlocks[numAllocatedBlocks].size = block_sz;
    numAllocatedBlocks++;
} else {
    printf("MAX BLOCKS EXCEEDED\n");
}

- allocate each command in command line
- allocate each argv in a command
- allocating fields of a command should use the command's allocated space